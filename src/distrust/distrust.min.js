"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/distrust/api/helpers.ts
function findInTree(tree, searchFilter, args2 = { maxRecursion: 100 }) {
  const { walkable, ignore, maxRecursion } = args2;
  if (maxRecursion <= 0)
    return void 0;
  if (searchFilter(tree)) {
    return tree;
  }
  if (typeof tree !== "object" || tree == null)
    return void 0;
  let tempReturn;
  if (Array.isArray(tree)) {
    for (const value of tree) {
      tempReturn = findInTree(value, searchFilter, {
        walkable,
        ignore,
        maxRecursion: maxRecursion - 1
      });
      if (typeof tempReturn !== "undefined")
        return tempReturn;
    }
  } else {
    const toWalk = walkable == null ? Object.keys(tree) : walkable;
    for (const key of toWalk) {
      if (!Object.prototype.hasOwnProperty.call(tree, key) || ignore?.includes(key))
        continue;
      tempReturn = findInTree(tree[key], searchFilter, {
        walkable,
        ignore,
        maxRecursion: maxRecursion - 1
      });
      if (typeof tempReturn !== "undefined")
        return tempReturn;
    }
  }
  return tempReturn;
}
function cache(factory) {
  const cache2 = {};
  return () => {
    if ("current" in cache2)
      return cache2.current;
    const current = factory();
    cache2.current = current;
    return current;
  };
}
function proxyCache(factory, typeofIsObject = false) {
  const handlers = {};
  const cacheFactory = cache(factory);
  for (const key of Object.getOwnPropertyNames(Reflect)) {
    const handler = Reflect[key];
    if (key === "get") {
      handlers.get = (target, prop, r) => {
        if (prop === "prototype")
          return cacheFactory().prototype ?? Function.prototype;
        if (prop === Symbol.for("proxy.cache"))
          return cacheFactory;
        return Reflect.get(cacheFactory(), prop, r);
      };
      continue;
    }
    if (key === "ownKeys") {
      handlers.ownKeys = () => {
        const keys = Reflect.ownKeys(cacheFactory());
        if (!typeofIsObject && !keys.includes("prototype"))
          keys.push("prototype");
        return keys;
      };
      continue;
    }
    handlers[key] = function(target, ...args2) {
      return handler.apply(this, [cacheFactory(), ...args2]);
    };
  }
  return new Proxy(Object.assign(typeofIsObject ? {} : function() {
  }, {
    [Symbol.for("proxy.cache")]: cacheFactory
  }), handlers);
}
var init_helpers = __esm({
  "src/distrust/api/helpers.ts"() {
    "use strict";
  }
});

// src/distrust/modules/discordModules.ts
var Flux, React, Components;
var init_discordModules = __esm({
  "src/distrust/modules/discordModules.ts"() {
    "use strict";
    init_webpack();
    init_helpers();
    Flux = proxyCache(() => webpack_default.getModule((x) => x?.exports?.default?.Store));
    React = proxyCache(() => webpack_default.getModule((x) => x?.exports?.createElement));
    Components = proxyCache(() => webpack_default.getKeys(""));
  }
});

// src/distrust/api/webpack.ts
var Webpack, webpack_default;
var init_webpack = __esm({
  "src/distrust/api/webpack.ts"() {
    "use strict";
    init_modules();
    init_discordModules();
    Webpack = class {
      getModules() {
        if (!webpackRequire)
          throw new Error("Webpack not found. How did this even happen ??");
        return Object.values(webpackRequire.c);
      }
      waitForModule = waitForModule;
      getLength() {
        if (!webpackRequire)
          throw new Error("Webpack not found");
        return Object.keys(webpackRequire.c).length;
      }
      getModule(condition, options = {}) {
        const { all = false, raw = false } = options;
        const modules2 = this.getModules().filter(condition);
        if (all)
          return modules2;
        const module2 = modules2[0];
        return raw ? module2 : module2?.exports?.default ?? module2?.exports;
      }
      getStore(condition, options = {}) {
        const stores = Flux.Store.getAll();
        return stores.find((store) => store.getName() === condition);
      }
      getKeys(props, options = {}) {
        const propsArray = Array.isArray(props) ? props : [props];
        const condition = (module2) => {
          const exports2 = module2.exports;
          if (exports2 instanceof Object) {
            if (propsArray.every((prop) => prop in exports2)) {
              return true;
            }
            if (exports2.default instanceof Object && propsArray.every((prop) => prop in exports2.default)) {
              return true;
            }
          }
          return false;
        };
        return this.getModule(condition, options);
      }
      getPrototypes(props, options = {}) {
        const propsArray = Array.isArray(props) ? props : [props];
        const condition = (module2) => module2.exports instanceof Object && propsArray.every((prop) => prop in module2.exports.prototype);
        return this.getModule(condition, options);
      }
      getSource(match, options = {}) {
        const condition = (module2) => {
          const source = sources[module2.id];
          if (!source)
            return false;
          return typeof match === "string" ? source.includes(match) : match.test(source);
        };
        return this.getModule(condition, options);
      }
      getId(id2, options = {}) {
        const condition = (module2) => {
          return module2.id === id2.toString();
        };
        return this.getModule(condition, options);
      }
    };
    webpack_default = new Webpack();
  }
});

// src/distrust/api/logger.ts
var Logger, CoreLogger;
var init_logger = __esm({
  "src/distrust/api/logger.ts"() {
    "use strict";
    Logger = class _Logger {
      constructor(context) {
        this.context = context;
      }
      static logColor = "#5865F2";
      static logsHistory = [];
      log(level, message) {
        const formattedMessage = `[distrust:plugin:${this.context}] ${message.join(" ")}`;
        _Logger.logsHistory.push(formattedMessage);
        console[level](`%c[${this.context}]`, `color: ${_Logger.logColor}`, ...message);
      }
      info(...message) {
        this.log("log", message);
      }
      warn(...message) {
        this.log("warn", message);
      }
      error(...message) {
        this.log("error", message);
      }
      static getHistory() {
        return _Logger.logsHistory;
      }
    };
    CoreLogger = class _CoreLogger {
      constructor(context) {
        this.context = context;
      }
      static logColor = "#5865F2";
      static logsHistory = [];
      log(level, message) {
        const formattedMessage = `[distrust:core:${this.context}] ${message.join(" ")}`;
        _CoreLogger.logsHistory.push(formattedMessage);
        console[level](`%c[Core:${this.context}]`, `color: ${_CoreLogger.logColor}`, ...message);
      }
      info(...message) {
        this.log("log", message);
      }
      warn(...message) {
        this.log("warn", message);
      }
      error(...message) {
        this.log("error", message);
      }
      static getHistory() {
        return _CoreLogger.logsHistory;
      }
    };
  }
});

// src/distrust/api/patcher.ts
var Patcher;
var init_patcher = __esm({
  "src/distrust/api/patcher.ts"() {
    "use strict";
    init_logger();
    Patcher = class {
      log;
      patches;
      constructor(context) {
        this.log = new Logger(context);
        this.patches = /* @__PURE__ */ new Map();
      }
      addPatch(targetObject, methodName, originalMethod) {
        if (!this.patches.has(targetObject)) {
          this.patches.set(targetObject, /* @__PURE__ */ new Map());
        }
        this.patches.get(targetObject).set(methodName, originalMethod);
      }
      before(targetObject, methodName, beforeCallback) {
        const originalMethod = targetObject[methodName];
        if (!originalMethod || typeof originalMethod !== "function") {
          this.log.error(`Method "${methodName}" not found on the target object.`);
          return function() {
          };
        }
        this.addPatch(targetObject, methodName, originalMethod);
        targetObject[methodName] = (...args2) => {
          beforeCallback.apply(this, args2);
          return originalMethod.apply(this, args2);
        };
        return this.createUnpatchFunction(targetObject, methodName);
      }
      after(targetObject, methodName, afterCallback) {
        const originalMethod = targetObject[methodName];
        if (!originalMethod || typeof originalMethod !== "function") {
          this.log.error(`Method "${methodName}" not found on the target object.`);
          return function() {
          };
        }
        this.addPatch(targetObject, methodName, originalMethod);
        targetObject[methodName] = function() {
          const result = originalMethod.apply(this, arguments);
          afterCallback.call(this, this, result, arguments);
          return result;
        };
        return this.createUnpatchFunction(targetObject, methodName);
      }
      instead(targetObject, methodName, insteadCallback) {
        const originalMethod = targetObject[methodName];
        if (!originalMethod || typeof originalMethod !== "function") {
          this.log.error(`Method "${methodName}" not found on the target object.`);
          return function() {
          };
        }
        this.addPatch(targetObject, methodName, originalMethod);
        targetObject[methodName] = (...args2) => {
          return insteadCallback.apply(this, [originalMethod.bind(this), ...args2]);
        };
        return this.createUnpatchFunction(targetObject, methodName);
      }
      unpatchAll() {
        this.patches.forEach((methods, targetObject) => {
          methods.forEach((originalMethod, methodName) => {
            targetObject[methodName] = originalMethod;
          });
        });
        this.patches.clear();
        this.log.info("All patches have been removed.");
      }
      createUnpatchFunction(targetObject, methodName) {
        return () => {
          if (this.patches.has(targetObject) && this.patches.get(targetObject).has(methodName)) {
            targetObject[methodName] = this.patches.get(targetObject).get(methodName);
            this.patches.get(targetObject).delete(methodName);
            if (this.patches.get(targetObject).size === 0) {
              this.patches.delete(targetObject);
            }
            this.log.info(`Unpatched method "${methodName}" on the target object.`);
          }
        };
      }
    };
  }
});

// src/distrust/components/Components.tsx
function Divider({ style }) {
  return /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", { className: DividerClasses.sectionDivider, style });
}
var DividerClasses, TextClasses;
var init_Components = __esm({
  "src/distrust/components/Components.tsx"() {
    "use strict";
    init_helpers();
    init_webpack();
    DividerClasses = proxyCache(() => webpack_default.getKeys("sectionDivider"));
    TextClasses = proxyCache(() => webpack_default.getKeys("text-xs/normal"));
  }
});

// src/consts.ts
var MOD_VERSION;
var init_consts = __esm({
  "src/consts.ts"() {
    "use strict";
    MOD_VERSION = "0.0.1";
  }
});

// src/distrust/components/TabBar.tsx
var TabBar;
var init_TabBar = __esm({
  "src/distrust/components/TabBar.tsx"() {
    "use strict";
    init_discordModules();
    init_Components();
    TabBar = ({ tabs: tabs2 }) => {
      const [activeTab, setActiveTab] = React.useState(tabs2[0].id);
      const [hoveredTab, setHoveredTab] = React.useState(null);
      const handleTabClick = (tabId) => {
        setActiveTab(tabId);
      };
      const handleMouseEnter = (tabId) => {
        setHoveredTab(tabId);
      };
      const handleMouseLeave = () => {
        setHoveredTab(null);
      };
      return /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", { style: { textAlign: "center" } }, /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", { className: "channelTabBar" }, tabs2.map(
        (tab) => /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", { key: tab.id, style: { display: "inline-block" } }, /* @__PURE__ */ globalThis.distrust.common.react.createElement(
          "button",
          {
            className: `channelTabBarItem${activeTab === tab.id ? " selected" : ""}`,
            onClick: () => handleTabClick(tab.id),
            onMouseEnter: () => handleMouseEnter(tab.id),
            onMouseLeave: handleMouseLeave,
            style: { position: "relative" }
          },
          tab.label,
          activeTab === tab.id && /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", { className: "highlight" }),
          (hoveredTab === tab.id || activeTab === tab.id) && /* @__PURE__ */ globalThis.distrust.common.react.createElement(
            "div",
            {
              className: "hoverIndicator",
              style: {
                position: "absolute",
                bottom: 0,
                left: 0,
                width: "100%",
                height: 2,
                borderRadius: 3,
                backgroundColor: activeTab === tab.id ? "var(--control-brand-foreground)" : "var(--brand-experiment)"
              }
            }
          )
        ))
      ), /* @__PURE__ */ globalThis.distrust.common.react.createElement(Divider, null)), /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", null, tabs2.map((tab) => activeTab === tab.id && tab.element())));
    };
  }
});

// src/distrust/api/css.ts
var injectCSS, uninjectCSS;
var init_css = __esm({
  "src/distrust/api/css.ts"() {
    "use strict";
    injectCSS = (id2, css) => {
      const inject = () => {
        let el = document.getElementById(id2);
        if (!el) {
          el = document.createElement("style");
          el.id = id2;
          document.head.appendChild(el);
        }
        if (el.textContent !== css)
          el.textContent = css;
      };
      document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", inject) : inject();
    };
    uninjectCSS = (name) => {
      const style = document.getElementById(name);
      if (style) {
        document.head.removeChild(style);
      }
    };
  }
});

// src/distrust/components/Distrust.tsx
var DistrustIcon;
var init_Distrust = __esm({
  "src/distrust/components/Distrust.tsx"() {
    "use strict";
    DistrustIcon = () => {
      return /* @__PURE__ */ globalThis.distrust.common.react.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "4.25 4 11.75 7" }, /* @__PURE__ */ globalThis.distrust.common.react.createElement(
        "path",
        {
          d: "M 8 4 L 13 4 C 17 4 17 11 13 11 L 8 11 C 7 11 7 10 8 10 L 10 10 C 11 10 11 9 10 9 L 5 9 C 4 9 4 8 5 8 L 8 8 C 9 8 9 7 8 7 L 7 7 C 6 7 6 6 7 6 L 11 6 C 12 6 12 5 11 5 L 8 5 C 7 5 7 4 8 4",
          fill: "#5865F2"
        }
      ));
    };
  }
});

// src/distrust/components/Plugins.tsx
var PluginCard;
var init_Plugins = __esm({
  "src/distrust/components/Plugins.tsx"() {
    "use strict";
    init_discordModules();
    PluginCard = ({ plugin }) => {
      const [isToggled, setIsToggled] = React.useState(false);
      return /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", { style: { marginBottom: "10px" } }, /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", { className: "card", onClick: () => setIsToggled(!isToggled), style: { cursor: "pointer" } }, /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", { className: "info" }, /* @__PURE__ */ globalThis.distrust.common.react.createElement("h3", null, plugin.name), /* @__PURE__ */ globalThis.distrust.common.react.createElement("p", null, plugin.version)), /* @__PURE__ */ globalThis.distrust.common.react.createElement("p", null, plugin.author), /* @__PURE__ */ globalThis.distrust.common.react.createElement("p", null, plugin.description)));
    };
  }
});

// src/distrust/renderer/mods/settings.tsx
var settings_exports = {};
__export(settings_exports, {
  VersionInfo: () => VersionInfo,
  default: () => settings_default,
  manifest: () => manifest,
  patches: () => patches,
  start: () => start,
  stop: () => stop
});
async function start() {
  injectCSS("settings", `
    .channelTabBarItem {
      margin-right: 10px;
      padding: 5px 10px;
      cursor: pointer;
      color: white;
      background: transparent;
      position: relative;
    }
    
    .highlight {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 5px;
      background-color: transparent;
    }
    
    .channelTabBarItem.selected {
      background-color: transparent;
    }
    .card {
      background-color: var(--background-secondary);
      padding: 9px;
      margin: 3px;
      border-radius: 9px;
    }
    .info {
      display: flex;
      justify-content: space-between;
    }
    h3, p {color: var(--font-primary); margin: 0;}`);
  const settingsPage = await waitForModule((x) => x?.exports?.default?.prototype?.renderSidebar);
  injector.after(settingsPage?.prototype, "getPredicateSections", (args2, b, c) => {
    console.log(args2, b, c);
    b.unshift({ section: "client-mod-page", label: "uwu", element: () => /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", null, " ", /* @__PURE__ */ globalThis.distrust.common.react.createElement(TabBar, { tabs }), " "), icon: () => DistrustIcon });
  });
  settingsLogger.info("Starting setting plugin");
}
function VersionInfo() {
  return /* @__PURE__ */ globalThis.distrust.common.react.createElement("span", { className: TextClasses["text-xs/normal"], style: { color: "var(--text-muted)" } }, "distrust (", MOD_VERSION, ")");
}
function stop() {
  uninjectCSS("settings");
  settingsLogger.info("Stopping setting plugin");
}
var settingsLogger, injector, manifest, tabs, settings_default, patches;
var init_settings = __esm({
  "src/distrust/renderer/mods/settings.tsx"() {
    "use strict";
    init_patcher();
    init_logger();
    init_Components();
    init_consts();
    init_modules();
    init_TabBar();
    init_css();
    init_Distrust();
    init_plugins();
    init_Plugins();
    settingsLogger = new Logger("Settings");
    injector = new Patcher("settings");
    manifest = {
      name: "Settings",
      version: "1.0.0",
      description: "settings plugin coremod ;3",
      authors: ["kaan"]
    };
    tabs = [
      {
        id: 1,
        label: "Test",
        element: () => /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", null, "Test Content")
      },
      {
        id: 2,
        label: "Test",
        element: () => /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", null, "Test Content")
      },
      {
        id: 3,
        label: "Plugins",
        element: () => /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", null, plugins.map((plugin) => /* @__PURE__ */ globalThis.distrust.common.react.createElement(PluginCard, { plugin })))
      }
    ];
    settings_default = tabs;
    patches = [
      {
        find: ".versionHash",
        replacements: [
          {
            match: /appArch,children:.{0,200}?className:\w+\.line,.{0,100}children:\w+}\):null/,
            replace: `$&,distrust.plugins.getExports('settings').VersionInfo()`
          }
        ]
      }
    ];
  }
});

// src/distrust/renderer/mods/noDevtoolsWarnings.ts
var noDevtoolsWarnings_exports = {};
__export(noDevtoolsWarnings_exports, {
  manifest: () => manifest2,
  patches: () => patches2,
  start: () => start2
});
var logger, manifest2, start2, patches2;
var init_noDevtoolsWarnings = __esm({
  "src/distrust/renderer/mods/noDevtoolsWarnings.ts"() {
    "use strict";
    init_logger();
    logger = new Logger("NoDevtoolsWarnings");
    manifest2 = {
      name: "NoDevToolsWarnings",
      version: "1.0.0",
      description: "Removes DevTools warnings and prevents you from getting logged out when closing Discord with DevTools enabled.",
      authors: ["Evie"]
    };
    start2 = () => {
      logger.info("Starting NoDevToolsWarnings");
    };
    patches2 = [
      {
        find: "UserDefenses:",
        replacements: [
          {
            match: /UserDefenses:function\(\)\{(.+?)\}/,
            replace: "UserDefenses:function(){return ()=>{}}"
          }
        ]
      }
    ];
  }
});

// src/distrust/renderer/mods/recovery/index.tsx
var recovery_exports = {};
__export(recovery_exports, {
  manifest: () => manifest3,
  start: () => start3,
  startErrors: () => startErrors,
  stop: () => stop2
});
function startMainRecovery() {
  const log = (reason) => logger2.info(reason), err = (reason) => logger2.error(reason);
  log("Starting main recovery methods.");
  if (!ModalModule) {
    err("Could not find `openModalLazy` Module.");
    return;
  }
  try {
    RouteModule?.transitionTo("/channels/@me");
  } catch {
    err("Failed to transition to '/channels/@me'.");
  }
  try {
    Flux.dispatch({ type: "CONTEXT_MENU_CLOSE" });
  } catch {
    err("ContextMenu's could not be closed.");
  }
  try {
    ModalModule.closeAllModals();
  } catch {
    err("Could not close (most) modals.");
  }
  log("Ended main recovery.");
}
async function start3() {
  injectCSS(
    "recovery",
    `[class*=errorPage] [class*=buttons_] {
      flex-direction: column;
      align-items: center;
    }
    [class*=errorPage] [class*=buttons_] [class*=button__] {
      width: 400px;
      margin: 5px;
    }
    .distrust-recovery-button {
      width: var(--custom-button-button-lg-width);
      height: var(--custom-button-button-lg-height);
      min-width: var(--custom-button-button-lg-width);
      min-height: var(--custom-button-button-lg-height);
      background-color: var(--button-danger-background) !important;
    }
    [class*=errorPage] [class*=scrollbarGhostHairline] {
      white-space: break-spaces;
      width: 80vw;
      text-align: center;
    }
    `
  );
  const ErrorScreen = await waitForModule((x) => x?.exports?.default?.toString?.()?.includes(".AnalyticEvents.APP_CRASHED"));
  void startErrors();
  injector2.after(
    ErrorScreen.prototype,
    "render",
    (instance, res, args2) => {
      if (!instance.state?.error)
        return;
      const {
        props: { children }
      } = findInTree(res, (x) => Boolean(x?.action))?.action;
      if (!instance.state.error)
        return;
      const stackError = instance.state.error.stack;
      const pluginId = stackError.match(PLUGIN_ID_FIND_REGEX);
      const invar = stackError.match(FIND_ERROR_NUMBER);
      children.push(
        /* @__PURE__ */ globalThis.distrust.common.react.createElement(globalThis.distrust.common.react.Fragment, null, /* @__PURE__ */ globalThis.distrust.common.react.createElement(
          ModalsModule.Button,
          {
            className: `replugged-recovery-button`,
            onClick: () => {
              startMainRecovery();
              instance.setState({ error: null, info: null });
            }
          },
          "Recover Discord"
        ), /* @__PURE__ */ globalThis.distrust.common.react.createElement("div", { className: "recovery-parse" }, parser.parse(`\`\`\`${invar ? ReactErrors?.[invar[1]] : ""}

${stackError}\`\`\``)))
      );
    }
  );
}
function stop2() {
  injector2.unpatchAll();
  uninjectCSS("recovery");
}
async function startErrors() {
  ReactErrors = await fetch(ReactErrorList).then((response) => response.json()).catch(async (error) => {
    logger2.error("ReactErrorList Fail:", error);
    return await fetch(ReactErrorListFallback).then((response) => response.json());
  }).catch((error) => {
    logger2.error("ReactErrorListFallback Fail:", error, "\nFalling back to {}");
    return {};
  });
}
var PLUGIN_ID_FIND_REGEX, FIND_ERROR_NUMBER, ReactErrorList, ReactErrorListFallback, logger2, ReactErrors, injector2, parser, ModalsModule, manifest3, ModalModule, RouteModule;
var init_recovery = __esm({
  "src/distrust/renderer/mods/recovery/index.tsx"() {
    "use strict";
    init_logger();
    init_webpack();
    init_discordModules();
    init_modules();
    init_patcher();
    init_helpers();
    init_css();
    PLUGIN_ID_FIND_REGEX = /plugin\/(.*?)\.asar/;
    FIND_ERROR_NUMBER = /invariant=(\d+)&/;
    ReactErrorList = "https://raw.githubusercontent.com/facebook/react/v18.2.0/scripts/error-codes/codes.json";
    ReactErrorListFallback = "https://raw.githubusercontent.com/facebook/react/v17.0.0/scripts/error-codes/codes.json";
    logger2 = new Logger("recovery");
    injector2 = new Patcher("recovery");
    parser = proxyCache(() => webpack_default.getModule((x) => x?.exports?.default?.parse));
    ModalsModule = proxyCache(() => webpack_default.getKeys(["ConfirmModal"]));
    manifest3 = {
      name: "Recovery",
      version: "1.0.0",
      description: "Allows people to recover their discord if it crashes",
      authors: ["kaan"]
    };
    ModalModule = proxyCache(() => webpack_default.getKeys("openModalLazy"));
    RouteModule = proxyCache(() => webpack_default.getKeys("transitionTo"));
  }
});

// src/distrust/devConsts.ts
var coreLogger;
var init_devConsts = __esm({
  "src/distrust/devConsts.ts"() {
    "use strict";
    init_logger();
    coreLogger = new CoreLogger("distrust");
  }
});

// src/distrust/renderer/mods/experiments.tsx
var experiments_exports = {};
__export(experiments_exports, {
  manifest: () => manifest4,
  patches: () => patches3,
  start: () => start4,
  stop: () => stop3
});
function start4() {
  coreLogger.info("Experiments are loading");
}
function stop3() {
  coreLogger.info("This plugin cant be stopped omegalul");
}
var manifest4, patches3;
var init_experiments = __esm({
  "src/distrust/renderer/mods/experiments.tsx"() {
    "use strict";
    init_devConsts();
    manifest4 = {
      name: "Experiments",
      version: "1.0.0",
      description: "Enables Developer Options/Experiments",
      authors: ["Evie"]
    };
    patches3 = [
      {
        find: /"displayName","(Developer)?ExperimentStore"/,
        replacements: [
          {
            match: /window\.GLOBAL_ENV\.RELEASE_CHANNEL/g,
            replace: `"staging"`
          },
          {
            match: /(isDeveloper:{configurable:!1,get:\(\)=>)\w+/g,
            replace: `$1true`
          },
          {
            match: /=\(0,\w+\.isStaffEnv\)\(\w+\.default\.getCurrentUser\(\)\)/,
            replace: "=true"
          }
        ]
      }
    ];
  }
});

// src/distrust/renderer/managers/plugins.ts
function getExports(id2) {
  return plugins.find((plugin) => plugin.manifest.name.toLowerCase() == id2.toLowerCase());
}
var plugins;
var init_plugins = __esm({
  "src/distrust/renderer/managers/plugins.ts"() {
    "use strict";
    plugins = [(init_settings(), __toCommonJS(settings_exports)), (init_noDevtoolsWarnings(), __toCommonJS(noDevtoolsWarnings_exports)), (init_recovery(), __toCommonJS(recovery_exports)), (init_experiments(), __toCommonJS(experiments_exports))];
  }
});

// src/distrust/renderer/index.ts
function startAll() {
  plugins.forEach((plugins2) => plugins2.start());
}
var init_renderer = __esm({
  "src/distrust/renderer/index.ts"() {
    "use strict";
    init_plugins();
  }
});

// src/distrust/api/modules.ts
function patch(modules, id, module) {
  sources[id] = module.toString();
  let hasPatches = false;
  plugins.forEach((plugin) => {
    if (plugin.patches) {
      const source = sources[id];
      plugin.patches.forEach((patch2) => {
        let hasMatch = false;
        if (typeof patch2.find === "string") {
          hasMatch = source.includes(patch2.find);
        } else if (patch2.find instanceof RegExp) {
          hasMatch = patch2.find.test(source);
        }
        if (hasMatch) {
          patch2.replacements.forEach((replacement) => {
            sources[id] = sources[id].replace(replacement.match, replacement.replace);
            coreLogger.info(id, replacement, sources[id]);
          });
          hasPatches = true;
        }
      });
    }
  });
  function newModule(...args) {
    try {
      let bestModule;
      if (hasPatches) {
        bestModule = eval(`// PatchedSourceUwU ${id}

(${sources[id]})
//# sourceURL=distrust://webpack/${id}`);
      } else {
        bestModule = module;
      }
      return bestModule.apply(this, args);
    } finally {
      for (const listener of listeners) {
        listener.apply(this, args);
      }
    }
  }
  newModule.toString = () => sources[id].toString();
  newModule.original = module;
  modules[id] = newModule;
}
function waitForModule(filter, options = {}) {
  const cache2 = webpack_default.getModule(filter, options);
  if (cache2) {
    coreLogger.info("found", cache2);
    return Promise.resolve(cache2);
  }
  return new Promise((resolve) => {
    function listener(module2) {
      if (!filter(module2))
        return;
      listeners.delete(listener);
      resolve(module2?.exports?.default ?? cache2?.exports?.default);
    }
    listeners.add(listener);
  });
}
var WEBPACK_CHUNK, sources, webpackRequire, webpackChunk, listeners;
var init_modules = __esm({
  "src/distrust/api/modules.ts"() {
    "use strict";
    init_webpack();
    init_renderer();
    init_plugins();
    init_devConsts();
    WEBPACK_CHUNK = "webpackChunkdiscord_app";
    sources = {};
    webpackRequire = null;
    webpackChunk = window.webpackChunkdiscord_app ??= [];
    listeners = /* @__PURE__ */ new Set();
    webpackChunk.push([
      { some: () => true },
      {},
      (wpr) => {
        if (!wpr.b)
          return;
        webpackRequire = wpr;
        for (const id2 in wpr.m) {
          if (!Object.prototype.hasOwnProperty.call(wpr.m, id2))
            continue;
          patch(wpr.m, id2, wpr.m[id2]);
        }
        wpr.m = new Proxy(wpr.m, {
          set(target, key, value, r) {
            patch(target, key, value);
            return true;
          }
        });
        startAll();
      }
    ]);
  }
});

// src/distrust/index.tsx
init_modules();
init_logger();
init_patcher();
init_webpack();
init_discordModules();
init_plugins();
init_helpers();
init_css();
window.distrust = new class Distrust {
  logger = Logger;
  patcher = Patcher;
  webpack = webpack_default;
  common = { flux: Flux, react: React };
  plugins = { plugins, getExports, proxyCache };
  css = { injectCSS, uninjectCSS };
}();
